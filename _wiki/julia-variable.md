---
layout: wiki
title: Julia 变量
categories: Julia语法
description: Julia 常用语法使用方法
keywords: Julia
---

## 变量
Julia语言中,变量是与某个值相关联(或者绑定)的名字.可以用它来保存一个值,供以后的代码进行使用.变量名是大小写敏感的,并且不包含语义,也就是说,Julia语言中不会根据变量的名字来区别对待它.

Julia语言是对UTF-8字符支持的,所以可以使用Unicode字符作为变量名.很多Unicode数学符号可以使用反斜杠加Latex符号名再按键 tab可以直接打出来.举个例子`\delta tab`,这样就会给出δ这种复杂的变量名.

如果试图重定义一个已经在使用中的内置常量或者函数,Julia会报错.

### 合法的变量名
变量名字必须以英文字符、下划线或者编码大于00A0的Unicode字符的一个子集开头.具体来说指的就是Unicode字符分类中的(Lu/Ll/Lt/Lm/Lo/Nl)字母、(Sc/So)货币和其他符号以及一些其他像字母的符号。变量名的非首字母符号还允许使用感叹号!、数字(0-9以及Unicode中Nd/No类别中的Unicode字符)以及其他Unicode字符:变音符号和其他修改标记(Mn/Mc/Me/Sk类别)、标点和连接符(Pc类别)、引号和少许其他字符.

特别地，类似于加减乘除运算中的+、-等等符号可以像变量一样使用,`(+)`表示的是加函数,语句`(+) = f`这样会将它重新赋值处理.特别地,Julia语言中关键字是不能被用作变量一样进行赋值运算处理.

### 命名规范
虽然Julia语言对合法名字的限制非常烧,但是遵循以下这些命名规范:
+ 变量的名字采用小写;
+ 用下划线分隔名字中的单词,但是不鼓励使用下划线,除非在不使用下划线的时候名字会非常难读;
+ 类型(Type)和模块(Module)的名字使用大写字母开头,并且用大写字母而不是用下划线分隔单词;
+ 函数(Function)和宏(Macro)的名字使用小写,不使用下划线;
+ 会对输入参数进行更改的函数要使用!结尾.这类函数被称作是`mutating`或者是`in-place`函数,因为它们在被调用之后,不仅仅会返回一些值而且还会更改输入参数的内容.

## 整数和浮点数

整数和浮点值是算术和计算的基础,这些数值的内置表示被称作原始数值类型,并且整数和浮点数在代码中作为立即数时候称作数值字面量.

Julia提供了任意精度算术的软件支持,对于无法使用原生硬件表示的数据类型,所以Julia也能够高效地处理其数值运算.

**整数类型**

Int8:比特数量为8,最小值为-2^7 , 2^7-1

UInt8:比特数量为8,最小值为0, 2^8-1

Int16:比特数量为16,-2^15 , 2^15-1

UInt16:比特数量为16,0, 2^16-1

Int32:比特数量为32,-2^31 , 2^31-1

UInt32:比特数量为32,0, 2^32-1

Int64:比特数量为64,-2^63 , 2^63-1

UInt64:比特数量为64,0, 2^64-1

Int128:比特数量为128,-2^127 , 2^127-1

UInt128:比特数量为0,0, 2^128-1

Bool:比特数量为8,false(0),true(1)

**浮点类型**

Float16,精度为half,比特数量为16

Float32,精度为single,比特数量为32

Float64,精度为double,比特数量为64

另外对复数和有理数的完整支持是在这些原始数据类型之上建立起来的,Julia语言中有一个很灵活的、用户可扩展的类型提升系统,所有的数值类型都无需显式转换就可以很自然地相互进行计算.

### 整数
Julia 内置变量Sys.WORD_SIZE表明了目标系统中是32位系统还是64位系统.

无符号整数会通过`0x`前缀以及十六进制数0-9a-f(A-F)来输入和输出,无符号值的位数取决于十六进制数字的使用数量.

ans变量是Julia交互式语言中独有的变量,它保存着交互式会话中上一个表达式的运算结果,但是以其他方式运行的Julia代码中并没有这个变量.

二进制、八进制和十六进制的字面量都会产生无符号的整数类型.当字面量不是开头全是0的时候,它们二进制数据项的位数会是最少需要的位数.当开头都是0的时候,位数取决于一个字面量需要的最少位数,这里的字面量指的是一个有着同样长度但是开头均为1的数.这样用户就可以控制位数,那些无法使用UInt128类型存储下的值无法写成这样的字面量.

二进制、八进制和十六进制的字面量可以在前面紧接着加一个负号-,这样就可以产生一个和原字面量有着同样位数而值为原数的补码的数.

整型等原始数值类型的最小和最大可表示的值可以用`typemin`和`typemax`函数可以得到.

`typemin`和`typemax`函数返回的值类型总与所给参数的类型是相同的.

**除法错误**

div函数的整数除法有两种异常情况:除以零,以及使用-1去除最小的负数.这两种情况都会抛出一个DivideError错误,rem取余函数和mod取模函数在除零的时候抛出DivideError错误.

### 浮点数

浮点数字面量也使用标准格式表示,必要的时候可以使用E-表示法.

也存在十六进制的浮点数字面量,但只是适用于Float64值,一般使用p前缀及以2为底的指数来表示.

Julia也支持半精度浮点数(Float16),但是它们使用Float32进行模拟实现的.

下划线可以用作数字分隔符.

**浮点数中的零**

浮点数有两个零,一个是正零一个是负零,它们相互相等但是有着不同的二进制表示,可以使用bitstring函数进行内存字节查看.

**几种特殊的浮点值**
有三种特定的标准浮点值不和实数轴上任何一点对应

Float16,Inf16(正无穷,一个大于所有有限浮点数的数),-Inf16(负无穷,一个小于所有浮点数的数),NaN16(不是数,一个不和任何浮点值相等的值)

**机器精度**

大多数实数都无法用浮点数准确地表示,因此有必要知道两个相邻可表示的浮点数之间的距离,通常被称为机器精度.Julia语言中提供了eps函数用于计算浮点数之间的间隙.

```julia
eps(Float32)
```

两个相邻可表示的浮点数之间的距离并不是常数,数值越小,间距越大,数值也就越大,间距也就越大.换句话说就是,可表示的浮点数在实数轴上的零点附近最稠密,并且沿着远离零点的方向以指数型的速度变得越来越稀疏.

其中`nextfloat`和`prevfloat`两个函数分别返回基于参数的下一个更大或者是更小的可表示的浮点数:

**舍入模式**
一个数如果没有精确的浮点表示,就必须被舍入到一个合适的可表示的值.Julia 所使用的默认模式总是RoundNearset,指舍入到最接近的可表示的值,这个被舍入的值会使用尽量少的有效位数.

### 任意精度算术

Julia语言中包装了GNU Multiple Precision Arithmetic Library(GMP)和GNU MPFR Library.其中BigInt和BigFloat两种类型分别提供了任意精度的整数和浮点数.

可以从原始数字类型创建它们的构造器,也可以使用parse从AbstractString来构造它们,创建之后就可以像其他所有的数值类型一样参与算术运算.

```julia
parse(BigInt,"123456789012345678901234567890") + 1
BigFloat(2.0^66) / 3
BigInt(typemax(Int64)) + 1
```

注意:原始类型与BigInt/BigFloat之间的类型提升并不是自动的,需要明确地指定类型进行转化.

```julia
setrounding(BigFloat,RoundUp) do
    BigFloat(1) + parse(BigFloat,"0.1")
end

setrounding(BigFloat,RoundDown) do
    BigFloat(1) + parse(BigFloat,"0.1")
end

```

### 数值字面量系数
为了让常见的数值公式和表达式更清楚,Julia允许变量直接跟在一个数值字面量之后,暗指的是乘法.例如多项式写作以下的形式

```julia
x = 3
y = 2x^2+3x+1
```

同样也可以作为括号表达式的系数,表示的是表达式与变量之间相乘的关系.
### 零和一的字面量
Julia 提供了0和1的字面量函数,可以返回特定类型或者所给变量的类型.
```julia
zero(Float32)
one(1.0)
```

