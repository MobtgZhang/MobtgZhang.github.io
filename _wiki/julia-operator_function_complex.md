---
layout: wiki
title: Julia 数学运算、初等函数、复数和有理数
categories: Julia语法
description: Julia 常用语法使用方法
keywords: Julia
---

# 数学运算和初等函数
## 算术运算符
+x,一元加法运算符,全等操作
-x,一元减法运算符,将值变为其相反数
x+y,二元加法运算符,执行加法
x-y,二元减法运算符,执行减法
x*y,二元乘法运算符,执行乘法
x/y,除法运算符,执行除法
x÷y,整除,取`x/y`的整数部分
x\y,反向除法,等价于`y/x`
x^y,幂操作符,x的y次幂
x%y,取余,等价于rem(x,y)

以及对Bool类型的否定
!x,否定,将true和false之间互换

## 位运算符
~x,按位取反
x&y,按位与
x|y,按位或
x^b,按位异或
x>>>y,逻辑右移
x>>y,算术右移
x<<y,逻辑/算术左移

## 复合赋值操作符
二元运算和位运算的复合赋值操作符有下面几种:
+=,-=,*=,/=,\=,÷=,%=,^=,&=,|=,=,>>>=,>>=,<<=

## 向量化dot运算符
Julia中,每个二元运算符都有一个dot运算符与之对应,例如.^表示向量被Julia逐个元素地执行^运算.这个语法来源于MATLAB中的语法方法.
实际上,a.^b被解析为dot调用(^).(a,b),这样会执行broadcast操作,这种操作方法能够结合数组和标量、相同大小的数组(元素之间的运算)、甚至是不同形状的数组(行、列向量结合生成矩阵).

## 数值比较
标准的比较操作对所有原始数值类型有定义:
==,!=,≠,<,<=,≤,>,>=,≥

整数的比较方式是标准的按位比较,浮点数的比较方式遵循IEEE 754标准.
+ 有限数的大小顺序.
+ +0等于但不大于-0.
+ Inf等于自身,并且大于处理NaN以外的所有数.
+ -Inf等于自身,并且小于除了NaN以外的所有数.
+ NaN不等于、不小于并且不大于任何数值,包括自己.

Julia中额外的测试函数,例如下面的几种基本操作函数
+ `isequal(x,y)`,x与y是完全相同的
+ `isfinite(x)`,x是有限大的数字
+ `isinf(x)`,x是(正/负)无穷大
+ `isnan(x)`,x是NaN

isequal认为NaN之间是相等的
```julia
isequal(NaN,NaN)
isequal([1 NaN],[1 NaN])
isequal(NaN,NaN32)
```
有符号、无符号整数以及浮点数之间的混合类型比较是较为麻烦的,所以上述的函数主要是为了解决上述这个问题.
对于其他类型,isequal会默认调用`==`,所以如果给自定义的类型定义相等,那么就只需要为`==`增加一个方法,如果定义一个自己的相等函数,还需要可能定义一个对应的hash方法,用于确保`isequal(x,y)`隐含着`hash(x)==hash(y)`.

## 链式比较

Julia语言中允许链式比较
```julia
1<2<=2<3<=3
```

链式比较在写数值代码的时候特别方便,它使用`&&`运算符比较标量,数组则使用`&`进行按元素进行比较.例如,`0.<A<.1`这样会得到一个boolean数组,如果A的元素都在0和1之间则数组元素就都是true.

注意链式比较表达式的执行顺序:
```julia
v(x) = (println(x);x)
println(v(1)<v(2)<=v(3))
```

与Julia函数一样,一些初等函数可以通过点语法f.(A)以"向量化"的方式作用于数组和其他集合上.例如,sin.(A)会计算A中每个元素sin值.

## 数值转换
Julia的三种数值转换方式

+ `T(x)`和`convert(T,x)`都会将类型`x`转化为`T`类型.
+ `x%T`是将整数`x`转换为整型`T`,与`x`模`2^n`的结果是一致的,其中`n`是`T`的位数.也就是说,二进制表示是被砍掉一部分的.
+ 舍入函数接收一个`T`类型的可选参数,例如`round(Int,n)`是`Int(round(x))`的简写版本.

舍入函数包括有以下的几种
+ `round(x)`,x舍入到最接近的整数,返回值类型为`typeof(x)`
+ `round(T,x)`,x舍入到最接近的整数,返回值类型为`T`
+ `floor(x)`,x舍入到-Inf,返回值类型为`typeof(x)`
+ `floor(T,x)`,x舍入到-Inf,返回值类型为`T`
+ `ceil(x)`,向+Inf方向取整,返回值类型为`typeof(x)`
+ `ceil(T,x)`,向+Inf方向取整,返回值类型为`T`
+ `trunc(x)`,x向0取整,返回值类型为`typeof(x)`
+ `trunc(T,x)`,x向0取整,返回值类型为`T`

一些常见的运算函数
+ `div(x,y)`或者是`x÷y`:截断除法,商向零近似处理
+ `fld(x,y)`:向下取整除法,商向-Inf近似
+ `cld(x,y)`:向上取整除法,商向+Inf近似
+ `rem(x,y)`:取余;满足`x==div(x,y)*y+rem(x,y)`;符号与`x`一致
+ `mod(x,y)`:取模;满足`x==fld(x,y)*y+mod(x,y)`;符号与`y`一致
+ `mod1(x,y)`:偏移1的`mod`;若`y>0`,则返回`r(0,]`,若`y<0`,则`[y,0)`并且满足`mod(r,y)==mod(x,y)`
+ `mod2pi(x)`:以2pi为基取模;`0<=mod2pi(x)<2pi`
+ `divrem(x,y)`:返回`(div(x,y),rem(x,y))`
+ `fldmod(x,y)`:返回`(fld(x,y),mod(x,y))`
+ `gcd(x,y,...)`:`x,y,...`的最大公约数
+ `lcm(x,y,...)`:`x,y,...`的最小公倍数

## 除法函数
符号和绝对值函数
`abs(x)`,x的模
`abs2(x)`,x的模的平方
`sign(x)`,表示x的符号,返回-1,0或+1
`signbit(x)`,表示符号位是true或false
`copysign(x,y)`,返回一个数,其值等于x的模,符号与y一致
`flipsign(x,y)`,返回一个数,其值等于x的模,符号与x*y一致
## 幂、对数与平方根
`sqrt(x),√x`,x的平方根
`cbrt(x),³√x`,x的立方根
`hypot(x,y)`,当直角边的长度为x和y时候,直角三角形斜边的长度
`exp(x)`,自然指数函数在x处的值
`expm1(x)`,当x接近0时候的`exp(x)-1`的精确值
`ldexp(x,n)`,x*2^n的高效算法
`log(x)`,x的自然对数
`log(b,x)`,以b为底x的对数
`log2(x)`,以2为底x的对数
`log10(x)`,以10为底x的对数
`log1p(x)`,当x接近0时候的`log(1+x)`的精确值
`exponent(x)`,x的二进制指数
`significand(x)`,浮点数x的二进制有效数(也就是尾数)

## 三角函数和双曲函数
`sin,cos,tan,cot,sec,csc,`
`sinh,cosh,tanh,coth,sech,csch,`
`asinh,acosh,atanh,acoth,asech,acsch,`
`sinc,cosc`

注意`cospi(x)`和`sinpi(x)`分别用来对`sin(pi*x)`和`cos(pi*x)`进行更精确的计算.

计算角度值而非弧度制
`sind,cosd,tand,cotd,secd,cscd`
`asind,acosd,atand,acotd,asecd,acscd`
## 特殊函数
参考文档 SpecialFunction.jl,其中提供了许多其他的特殊数学函数.

# 复数和有理数
Julia语言中包含有预定义的复数和有理数类型,并且支持它们的各种标准数学运算和初等函数.由于也定义了复数与分数的类型转换与类型提升,故而对预定义类型的任意组合进行的操作都会标签得如语气的一致.

## 复数

在Julia语言中,全局常量`im`被绑定到复数i,表示-1的主平方根.这样就可以对复数进行各种标准的算术操作:
```julia
1+2im
(1+2im) * (2-3im)
(1+2im) / (2+5im)
(1+2im) + (2+5im)
(-3+2im) - (5-3im)
(-1+2im)^2
(-1+2im)^(8+5im)
3(3+9im)
7(2-5im)^2
3(2-5im)^-1.0
```
可以不同的实数类型与复数类型进行运算.注意
```julia
3/4im == 3/(4*im) == -(3/4*im)
```
复数的一些标准函数:`real`(实部),`imag`(虚部),`conj`(共轭复数),`abs`(复数的模),`abs2`(取平方后的绝对值),`angle`(以弧度为单位的相位角)

## 有理数
Julia中有一个用于表示整数精确比值的分数类型,分数通过`//`运算符构建.
```julia
17//8
23//9
```
使用函数`numberator`和`denominator`可以得到标准化之后的分子和分母.
```julia
numberator(17//8)
denominator(23//5)
```
同样对于分数值的比较操作也是可以的,很多操作符(比较运算符号、算术运算符号)对于分数值之间的比较也是可以的.

Julia可以接收构建无穷分数值,但是不接受试图构建一个NaN分数值,
```julia
# 接受以下的无穷值分数
1//0
# 不接受以下的非数值分数值
0//0
```

各种类型的值可以交互进行运算处理.











